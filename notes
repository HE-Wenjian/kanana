-*- mode:org; -*-

* notes from meeting
see "DWARF Call Frame information" under "understandings"
* confusion I have
* issues I see
** exception handling
   issue mentioned in "A Runtime Code Modification Method for
   Application Programs" (reference 14 in Katana). Can't patch code that
   generates exceptions unless patch .eh_frame
** patching debug data?
   any point?
** existing state
   can it be used to fix existing problems in state or only patch vulnerabilities? 
** global initializers
   Can it be used to change existing values of variables that have
   already changed from the initial value?
** rolling back
   p.8 how can we role back a patch anyway if we insert a jump at the
   beginning of a function that didn't have one before, presumably
   overwriting some instruction. Would we store this instruction
   somewhere?
** TODO actual code
   need to get Tenessee Valley code still
** multithreaded?
* things to keep in mind
** some way to check compatibility with target before applying the patch
** patching static variables
   p. 9 of "A Runtime Code Modification Method for Application Programs" mentions
   that this is tricky and is a limitation of their kaho system
** speeding up the patching
   what if create an extra thread in the target to handle loading, etc
   of the new data before actually patching?
** application speed gets worse as the app runs due to worse spatial locality
** fix tainted state
   callbacks at beginning and end of patch? Talked about on p. 5 of
   the POLUS paper
** backtracing from within a program
   is possible using the backtrace call
   http://www.gnu.org/software/libtool/manual/libc/Backtraces.html
   generally requires compiling with -rdynamic
** it appears that ld does not write all symbols from the symbol table into the hash table
* references:
**misc
*** ELFsh/ERESI papers
**** http://phrack.org/issues.html?issue=61&id=8&mode=txt
     Paper on ALTPLT technique, ET_REL injection, and more
**** http://www.phiral.net/phrack/phrack/63/p63-0x09_Embedded_Elf_Debugging.txt
     Long, useful paper on various binary manipulation
     techniques. Talks about rewriting ELF files to allow calls to
     previously unused functions in dynamic libraries. Unfortunately,
     I'm not sure  this will work at runtime (although I should check to
     find out how the address of the GOT and PLT tables is being
     determined. Check out .dynamic). Around DUMP 29 in the article it
     appears that they might actually be doing this, read in more
     depth. Also consider the section entitled 
     "Runtime section injection algorithm in memory". It talks about
     injecting things at runtime
*** http://artofhacking.com/files/phrack/phrack61/live/aoh_p61-0x08.htm
*** http://www.ibm.com/developerworks/power/library/pa-spec12/
*** http://developers.sun.com/solaris/articles/elf.html
*** http://www.linuxjournal.com/node/1060/print
*** libdwarf: http://reality.sgiweb.org/davea/dwarf.html
*** powerpoint on ELF http://www.trunix.org/programlama/os/sp13.ppt
*** x86 calling conventions http://unixwiz.net/techtips/win32-callconv-asm.html
*** elfutils: http://www.blackhat.com/presentations/bh-asia-02/Clowes/elfutils-bh2.tar
    misc tools for patching into elf files. I think it patches stationary files rather
    than running ones, but the same techniques could be extrapolated. Therefore, it could
    be used for example purposes
*** Understanding ELF using readelf and objdump" 
    http://www.linuxforums.org/articles/understanding-elf-using-readelf-and-objdump_125.html
    decent introduction to ELF          
*** Practical Dynamic Software Updating for C
    http://www.cs.umd.edu/~neamtiu/pubs/pldi06neamtiu.pdf
    fairly in-depth look at hot patching, along with actual metrics
    of a system they built called Ginseng
    Disadvantage: seems to require the currently running software to
    be built supporting it. Handles type transformation in a way that is perhaps not as
    nice as using the DWARF information. Seems to allocate fixed
    padding for types to expand, cannot expand beyond that although
    they discuss some possible techniques for removing this limitation

    Features loop extraction (p. 4) which is pretty nifty

    Like Katana has issues with multithreaded (p. 5)

    Has code available at http://www.cs.umd.edu/projects/PL/dsu/software.shtml
*** "A Runtime Code Modification Method for Application Programs" 
    http://ols.fedoraproject.org/OLS/Reprints-2008/yamato-reprint.pdf
    proposes a system faster than pannus and livepatch. Like pannus
    relies on a kernel module. Talks about some limitations of
    hot-patching systems. Their system can't handle shared libraries
    not already loaded and has some issues with static variables
*** POLUS http://portal.acm.org/citation.cfm?id=1248820.1248860
    dates from 2007
    robus/developed patching system that allows patching tainted state
    and rolling back updates. Has code available at http://sourceforge.net/projects/polus/files/
    
    POLUS and Ginseg both rely on the CIL framework
    (http://www.eecs.berkeley.edu/~necula/Papers/cil_cc02.pdf). This
    gives them a disadvantage in that they are tied to C. We could
    theoretically work on any language that compiles to ELF files with
    DWARF information. TODO: demonstrate patching an objective C
    program if possible.

*** ELF format references
    http://www.skyfree.org/linux/references/ELF_Format.pdf
*** Phrack on runtime code injection
    http://phrack.org/issues.html?issue=59&id=8#article
**call frame info/DWARF/Exception Handling
*** dwarf standard http://dwarfstd.org/Dwarf3.pdf
**** Call frame information in section 6.4 (p. 120 in the pdf, marked as p.108)
**** section 6.4.4 discusses exactly how to practically unwind the stack
**** example in Appendix D.6 (page 217 in the pdf)
*** dwarf intro http://dwarfstd.org/Debugging%20using%20DWARF.pdf
*** A Consumer Library Interface to DWARF 
    unfortunately oldish, from 2002
    ftp://ftp.software.ibm.com/software/os390/czos/dwarf/libdwarf2.1.pdf
    section 5.12 (pdf page 37) talks about stack frames
*** "C++ Exception Handling"
    from http://ieeexplore.ieee.org/search/wrapper.jsp?arnumber=895109
    probably not terribly useful but talks a bit about how exception
    handling is implemented in C++
*** x86-64 ABI
    http://www.x86-64.org/documentation/abi.pdf
    See section 6.2
*** email entitled "DWARF debugging intro, with hints re exception handling" from Sergey
  the text is below. Comment are in bold:
  The intro:

       http://dwarfstd.org/Debugging%20using%20DWARF.pdf

    Stack unwinding is part of the ABI, so some of it is covered in
  platform dev manuals. Look for "stack unwinding" here:

          http://www.x86-64.org/documentation/abi.pdf
          *useful stuff on precisely how x86-64 requires things to be.
          Talks about special functions the ABI requires to be defined*

    There may be more details in other similar manuals (e.g., HP's or Intel's).

    There seem to be bits of into on the GCC mailing list, but so far
  I had not found much in any organized form. Some links:

  http://refspecs.freestandards.org/LSB_3.0.0/LSB-Core-generic/LSB-Core-generic/ehframechpt.html
   *just describes the structure of the .eh_frame section*
  http://archives.devshed.com/forums/development-94/how-is-the-eh-frame-section-used-2316212.html
   *mentions source files relevant to eh_frame being bfd/elf-eh-frame.c in 
   binutils and gcc/dwarf2out.c in gcc*
  http://gcc.gnu.org/ml/gcc/1997-10/msg00312.html
   *just mentions that eh_frame contains Dwarf2 unwind info (from 1997)*
  http://gcc.gnu.org/ml/gcc/1997-10/msg00300.html
   *follow up to above. Not particularly interesting for our purposes*
  http://www.mailinglistarchive.com/gcc@gcc.gnu.org/msg29372.html
   *useful, talks about some more stuff in eh_frame. A later followup
   talks about LSDA, the Language Specific Data Area*
  http://readlist.com/lists/gcc.gnu.org/gcc/2/12822.html
    *doesn't look useful for this project, sounds like a bug in gcc for sparc*
    *Does mention the file unwind-dw2.c, not sure if it has relevance beyond sparc*

     Terms to watch out for: CFI, stack unwinding, personality routine.
  I recall there was a long post on the GCC list explaining the
  details of C++ personality stack unwinding, but I have been unable
  to locate it since.


    Best,

  --Sergey 

*** C++ ABI Exception Handling
    http://www.codesourcery.com/public/cxx-abi/exceptions.pdf
    Talks about exception handling in C++
    the exception routines are discussed in a little more depth at
    http://www.codesourcery.com/public/cxx-abi/abi-eh.html
    although the info there may be Itanium specific. See answers from
    stack overflow references below for more info
*** stack overflow question on exception handling
    http://stackoverflow.com/questions/307610/how-do-exceptions-work-behind-the-scenes-in-c
    One answer gives dissasembly and fairly detailed analysis

    Even better is
    http://stackoverflow.com/questions/329059/what-is-gxxpersonalityv0-for
    Gives some info about the personality routine and indicates where
    in libstd++ the implementation code can be found
*** exception handling implementation issues http://chasewoerner.org/exh.pdf
    discusses some of the implementation details of exception handling. Probably not
    terribly useful but could have a bit of interesting information or two
* existing software:
** livepatch
   doesn't look very sophisticated. Doesn't make sure target in a safe
   state. Can only patch integral values or pointers, can't patch
   changes to other global data.
   
** pannus
*** should look into it more to see exactly what it can do
*** requires writing out commands file (apparently by hand, I think)

** ksplice
a grep of its source code seems to indicate that it does not use dwarf
for type patching, but the paper does not seem to make it clear what
it does use
*** kernel live patching
*** fairly developed system, one reviewer who rejected Katana suggested looking at it more
*** http://www.ksplice.com/doc/ksplice.pdf
** Ginseng
   http://www.cs.umd.edu/projects/PL/dsu/software.shtml
   discussino about it above in the references section
** Polus
   http://sourceforge.net/projects/polus/files/
   discussion in references section
* helpful tools and libraries
** Radare http://www.radare.org
   general framework for binary manipulation with an aim towards
   reverse engineering. Not originally intended to run on a running
   process, but there seems to be a ptrace io wrapper plugin for it
   that allows it to do this. Claims some DWARF support, but it's not
   clear how extensive this is.
** Diablo http://diablo.elis.ugent.be/
   Only works on statically linked programs.
   Requires hastle with changing compiler toolchain.
   Focuses on link-time optimization.
   I'm not sure it has a great deal of bearing on the Katana project 

   todo: look at exactly what Diablo requires to be kept in the
         object files, why it requires 
** ERESI
   General ELF rewriting framework. Formerly elfsh. The etrace program
   (and corresponding libetrace) allow tracing (and I believe
   modifying) running code from within that code's memory space (thus
   it is much faster than ptrace, etc). More docs on elfsh than ERESI
   I think, perhaps read old phrack articles on elfsh to figure our
   etrace usage
   
   Reading
   http://s.eresi-project.org/inc/articles/p63-0x09_Embedded_Elf_Debugging.txt
   indicates that actually getting it into running code is a bit of a
   PITA. It requires either modifying the binary or setting LD_PRELOAD
   and restarting the (unmodified) binary. This is not ideal. What we
   want to do is get it into running code without halting the
   code. etrace has two advantages over ptrace. It is faster and it
   may work in places where ptrace is disabled for security
   reasons. Since we are not hacking anything, we shouldn't need to
   care about the security restrictions. Faster is nice, however. We
   could potentially use ptrace to embed etrace in the application and
   move from there. If ERESI doesn't include support for embedding
   etrace in currently running code, it might just be easier to write
   things ourselves.

   Playing around:
   I could not get the ERESI etrel_memory test in the
   testsuite/debugging directory to work. I fear I don't understand
   the reladd command properly. The included .esh script seems to be
   somewhat specific to the memory layout of the system it was tested on
** libelf
   Tutorial at
   http://people.freebsd.org/~jkoshy/download/libelf/article.html
   Sun also has a brief tutorial at http://developers.sun.com/solaris/articles/elf.html
   
   LGPL
* understandings
** C++ Exception Handling Process
   A good overview of the process is found at
   http://www.codesourcery.com/public/cxx-abi/abi-eh.html#base-framework
   Note that during unwinding, _Unwind_GetGR is used to get general
   purpose registers (there's a SetGR variant too) and
   _Unwind_GetIP/_Unwind_SetIP does the same for the instruction
   pointer (same as PC, right?)
*** The CIE in .eh_frame defines a pointer to the personality routine
    It also defines the Language Specific Data Area (LSDA), I should
    figure out exactly what goes in that. For code compiled by g++,
    the personality routine is __gxx_personality_v0. This is located
    in libstdc++. The code can be found in libsupc++/eh_personality.cc
    in the source code for libstd++.
*** invocation of C++ throw generates a call to __cxa_throw
*** __cxa_throw calls _Unwind_RaiseException
    This function is required to exist by (I believe) the C++ ABI. It
    is located in libgcc
*** _Unwind_RaiseException calls the personality routine (__gxx_personality_v0)
    The personality routine examines the exception handlers to
    determine which frame holds a handler for the current
    exception. TODO: I don't yet have a clear understanding of the way
    this data is stored and accessed. The C++ ABI document on
    exception handling (in references above) talks about the storage
    of exception records. Also, I'm not entirely positive
    whether it's _Unwind_RaiseException or the personality routine
    that deals with the actual details of traversing down the
    stack. __gxx_personality_v0 calls __gnu_unwind_frame, but I cannot
    find where this symbol is actually located. Reading
    http://www.codesourcery.com/public/cxx-abi/abi-eh.html#base-personality
    I think it's the _Unwind_RaiseException that handles the stack
    rather than the personality routine.
*** Once a handler is found, execution goes to __cxa_begin_catch
    Note that at this point the original call location of the
    exception has been wiped off the stack.
*** After the code in the catch block has executed, it makes a call to __cxa_end_catch

** DWARF Call Frame information
*** from meeting
need to understand dwarf CIEs better, sergey thinks that format might
already describe the kinds of offsets that we need in order to patch. This
might be useful in the PO format. Stack frame is similar to a struct

offsets with info on what you expect to find at each.

read more on frame description in unwinding process
possible that poking of bytes in unwinding process can also go into patching
*** my understanding
(from the Dwarf spec)
DWARF call frame information (stored in .debug_frame) basically
provides the means to build a large table with a row for each possible
address of the program counter. Each row contains expressions allowing
the stack to be unwound to the previous frame by defining columns for
1. the Call Frame Address (stack pointer at call site in previous
   frame)
2. the return address, i.e. the address where execution will resume
   when the current function returns
3. the values of all registers in the previous frame at the return
   address
The values of these columns are obviously not generally columns. They
are computed from other registers, etc (computation against the
stack pointer register allows retrieving values on the
stack). Dwarf defines an expression language, which includes
stack-based computation (i.e. a stack similar to RPN calculators,
 not the stack in use by the executing program).

Interestingly, while all of the columns except for the CFA are
supposedly defining registers, the register number defined is given by
a LEB128 number. This allows an arbitrarily large number of
"registers". Note again that some of these "registers" may be
specified in terms of calculations involving other "registers". An
appropriate interpreter of this information could treat register
numbers instead as memory addresses/offsets from the start of a
file/etc. If the initial row were taken to be the image of the
original binary, a following row would define all changes that were
made to the binary by a patch. Because columns may be specified by
expressions in terms of other columns, this could theoretically provide a means of
specifying the transformation of a running program into a patched
program based on the state  of the running program.

That said, while it's an interesting idea, I'm not sure I really see
the point (perhaps I'm missing something). As it doesn't actually
serve the same purpose as the contents of .debug_frame (or .eh_frame)
and requires reinterpretation of register numbers as addresses, it
would hardly be able to use existing code written for dealing with
Dwarf. For example, while the Dwarf standard calls for  LEB128 values
for the register numbers, libdwarf reads them as shorts, since no
existing architecture actually has 2^16 registers. So making the patch
information in patch objects formatted in the manner of DWARF FDEs
seems to me as though it would just be a hassle (and restrict the
addition of extra functionality should it be needed). We could certainly use it for
inspiration yes, but I'm not sure where the gain would be in actually
using the format. I suppose the only real advantage would be in trying
to promote a standard patch object format, since Dwarf is already a standard.
* definitions
** ET_REL
   ELF file type recognized by linux. Denotes relocatable object

* plans
** basic type-patching process
   read in the old type definition from DWARF information. Construct
   for each type a bijection between field name and field offset (from
   the starting address of any variable of that type). Then do the
   same for the new type definion. This allows us to construct a
   map from old offset and new offset (old offset -> field name -> new
   offset) unless of course the given variable has been eliminated. 


