-*- mode:org; -*-


* issues I see
** exception handling
   issue mentioned in "A Runtime Code Modification Method for
   Application Programs" (reference 14 in Katana). Can't patch code that
   generates exceptions unless patch .eh_frame
** patching debug data?
   any point?
** existing state
   can it be used to fix existing problems in state or only patch vulnerabilities? 
** global initializers
   Can it be used to change existing values of variables that have
   already changed from the initial value?
** rolling back
   p.8 how can we role back a patch anyway if we insert a jump at the
   beginning of a function that didn't have one before, presumably
   overwriting some instruction. Would we store this instruction
   somewhere?
** TODO actual code
   need to get Tenessee Valley code still
** multithreaded?
* things to keep in mind
** some way to check compatibility with target before applying the patch
** patching static variables
   p. 9 of "A Runtime Code Modification Method for Application Programs" mentions
   that this is tricky and is a limitation of their kaho system
** speeding up the patching
   what if create an extra thread in the target to handle loading, etc
   of the new data before actually patching?
** application speed gets worse as the app runs due to worse spatial locality
** fix tainted state
   callbacks at beginning and end of patch? Talked about on p. 5 of
   the POLUS paper
** backtracing from within a program
   is possible using the backtrace call
   http://www.gnu.org/software/libtool/manual/libc/Backtraces.html
   generally requires compiling with -rdynamic
* references:
**misc
*** http://www.phiral.net/phrack/phrack/63/p63-0x09_Embedded_Elf_Debugging.txt
*** http://artofhacking.com/files/phrack/phrack61/live/aoh_p61-0x08.htm
*** http://www.ibm.com/developerworks/power/library/pa-spec12/
*** http://developers.sun.com/solaris/articles/elf.html
*** http://www.linuxjournal.com/node/1060/print
*** libdwarf: http://reality.sgiweb.org/davea/dwarf.html
*** powerpoint on ELF http://www.trunix.org/programlama/os/sp13.ppt
*** x86 calling conventions http://unixwiz.net/techtips/win32-callconv-asm.html
*** elfutils: http://www.blackhat.com/presentations/bh-asia-02/Clowes/elfutils-bh2.tar
    misc tools for patching into elf files. I think it patches stationary files rather
    than running ones, but the same techniques could be extrapolated. Therefore, it could
    be used for example purposes
*** Understanding ELF using readelf and objdump" 
    http://www.linuxforums.org/articles/understanding-elf-using-readelf-and-objdump_125.html
    decent introduction to ELF          
*** Practical Dynamic Software Updating for C
    http://www.cs.umd.edu/~neamtiu/pubs/pldi06neamtiu.pdf
    fairly in-depth look at hot patching, along with actual metrics
    of a system they built called Ginseng
    Disadvantage: seems to require the currently running software to
    be built supporting it. Handles type transformation in a way that is perhaps not as
    nice as using the DWARF information

    Features loop extraction (p. 4) which is pretty nifty

    Like Katana has issues with multithreaded (p. 5)

    Has code available at http://www.cs.umd.edu/projects/PL/dsu/software.shtml
*** "A Runtime Code Modification Method for Application Programs" 
    http://ols.fedoraproject.org/OLS/Reprints-2008/yamato-reprint.pdf
    proposes a system faster than pannus and livepatch. Like pannus
    relies on a kernel module. Talks about some limitations of
    hot-patching systems. Their system can't handle shared libraries
    not already loaded and has some issues with static variables
*** POLUS http://portal.acm.org/citation.cfm?id=1248820.1248860
    robus/developed patching system that allows patching tainted state
    and rolling back updates
**call frame info/DWARF/Exception Handling
*** dwarf standard http://dwarfstd.org/Dwarf3.pdf
**** Call frame information in section 6.4 (p. 120 in the pdf, marked as p.108)
**** section 6.4.4 discusses exactly how to practically unwind the stack
**** example in Appendix D.6 (page 217 in the pdf)
*** dwarf intro http://dwarfstd.org/Debugging%20using%20DWARF.pdf
*** A Consumer Library Interface to DWARF 
    unfortunately oldish, from 2002
    ftp://ftp.software.ibm.com/software/os390/czos/dwarf/libdwarf2.1.pdf
    section 5.12 (pdf page 37) talks about stack frames
*** "C++ Exception Handling"
    from http://ieeexplore.ieee.org/search/wrapper.jsp?arnumber=895109
    probably not terribly useful but talks a bit about how exception
    handling is implemented in C++
*** x86-64 ABI
    http://www.x86-64.org/documentation/abi.pdf
    See section 6.2
*** email entitled "DWARF debugging intro, with hints re exception handling" from Sergey
  the text is below. Comment are in bold:
  The intro:

       http://dwarfstd.org/Debugging%20using%20DWARF.pdf

    Stack unwinding is part of the ABI, so some of it is covered in
  platform dev manuals. Look for "stack unwinding" here:

          http://www.x86-64.org/documentation/abi.pdf
          *useful stuff on precisely how x86-64 requires things to be.
          Talks about special functions the ABI requires to be defined*

    There may be more details in other similar manuals (e.g., HP's or Intel's).

    There seem to be bits of into on the GCC mailing list, but so far
  I had not found much in any organized form. Some links:

  http://refspecs.freestandards.org/LSB_3.0.0/LSB-Core-generic/LSB-Core-generic/ehframechpt.html
   *just describes the structure of the .eh_frame section*
  http://archives.devshed.com/forums/development-94/how-is-the-eh-frame-section-used-2316212.html
   *mentions source files relevant to eh_frame being bfd/elf-eh-frame.c in 
   binutils and gcc/dwarf2out.c in gcc*
  http://gcc.gnu.org/ml/gcc/1997-10/msg00312.html
   *just mentions that eh_frame contains Dwarf2 unwind info (from 1997)*
  http://gcc.gnu.org/ml/gcc/1997-10/msg00300.html
   *follow up to above. Not particularly interesting for our purposes*
  http://www.mailinglistarchive.com/gcc@gcc.gnu.org/msg29372.html
   *useful, talks about some more stuff in eh_frame. A later followup
   talks about LSDA, the Language Specific Data Area*
  http://readlist.com/lists/gcc.gnu.org/gcc/2/12822.html
    *doesn't look useful for this project, sounds like a bug in gcc for sparc*
    *Does mention the file unwind-dw2.c, not sure if it has relevance beyond sparc*

     Terms to watch out for: CFI, stack unwinding, personality routine.
  I recall there was a long post on the GCC list explaining the
  details of C++ personality stack unwinding, but I have been unable
  to locate it since.


    Best,

  --Sergey 

*** C++ ABI Exception Handling
    http://www.codesourcery.com/public/cxx-abi/exceptions.pdf
    Talks about exception handling in C++
    the exception routines are discussed in a little more depth at
    http://www.codesourcery.com/public/cxx-abi/abi-eh.html
    although the info there may be Itanium specific. See answers from
    stack overflow references below for more info
*** stack overflow question on exception handling
    http://stackoverflow.com/questions/307610/how-do-exceptions-work-behind-the-scenes-in-c
    One answer gives dissasembly and fairly detailed analysis

    Even better is
    http://stackoverflow.com/questions/329059/what-is-gxxpersonalityv0-for
    Gives some info about the personality routine and indicates where
    in libstd++ the implementation code can be found
*** exception handling implementation issues http://chasewoerner.org/exh.pdf
    discusses some of the implementation details of exception handling. Probably not
    terribly useful but could have a bit of interesting information or two
* existing software:
** livepatch: doesn't look very sophisticated
** pannus
*** should look into it more to see exactly what it can do
*** requires writing out commands file (apparently by hand, I think)

** ksplice
*** kernel live patching
*** fairly developed system, one reviewer who rejected Katana suggested looking at it more
*** http://www.ksplice.com/doc/ksplice.pdf

** Ginseng
   http://www.cs.umd.edu/projects/PL/dsu/software.shtml
   discussino about it above in the references section
* helpful tools and libraries
** Radare http://www.radare.org
   general framework for binary manipulation with an aim towards
   reverse engineering. Not originally intended to run on a running
   process, but there seems to be a ptrace io wrapper plugin for it
   that allows it to do this. Claims some DWARF support, but it's not
   clear how extensive this is.
** Diablo http://diablo.elis.ugent.be/
   Only works on statically linked programs.
   Requires hastle with changing compiler toolchain.
   Focuses on link-time optimization.
   I'm not sure it has a great deal of bearing on the Katana project 
** ERESI
   General ELF rewriting framework. Formerly elfsh. The etrace program
   (and corresponding libetrace) allow tracing (and I believe
   modifying) running code from within that code's memory space (thus
   it is much faster than ptrace, etc). More docs on elfsh than ERESI
   I think, perhaps read old phrack articles on elfsh to figure our
   etrace usage

** libelf
   Tutorial at
   http://people.freebsd.org/~jkoshy/download/libelf/article.html
   Sun also has a brief tutorial at http://developers.sun.com/solaris/articles/elf.html

* understandings
** C++ Exception Handling Process
   A good overview of the process is found at
   http://www.codesourcery.com/public/cxx-abi/abi-eh.html#base-framework
   Note that during unwinding, _Unwind_GetGR is used to get general
   purpose registers (there's a SetGR variant too) and
   _Unwind_GetIP/_Unwind_SetIP does the same for the instruction
   pointer (same as PC, right?)
*** The CIE in .eh_frame defines a pointer to the personality routine
    It also defines the Language Specific Data Area (LSDA), I should
    figure out exactly what goes in that. For code compiled by g++,
    the personality routine is __gxx_personality_v0. This is located
    in libstdc++. The code can be found in libsupc++/eh_personality.cc
    in the source code for libstd++.
*** invocation of C++ throw generates a call to __cxa_throw
*** __cxa_throw calls _Unwind_RaiseException
    This function is required to exist by (I believe) the C++ ABI. It
    is located in libgcc
*** _Unwind_RaiseException calls the personality routine (__gxx_personality_v0)
    The personality routine examines the exception handlers to
    determine which frame holds a handler for the current
    exception. TODO: I don't yet have a clear understanding of the way
    this data is stored and accessed. The C++ ABI document on
    exception handling (in references above) talks about the storage
    of exception records. Also, I'm not entirely positive
    whether it's _Unwind_RaiseException or the personality routine
    that deals with the actual details of traversing down the
    stack. __gxx_personality_v0 calls __gnu_unwind_frame, but I cannot
    find where this symbol is actually located. Reading
    http://www.codesourcery.com/public/cxx-abi/abi-eh.html#base-personality
    I think it's the _Unwind_RaiseException that handles the stack
    rather than the personality routine.
*** Once a handler is found, execution goes to __cxa_begin_catch
    Note that at this point the original call location of the
    exception has been wiped off the stack.
*** After the code in the catch block has executed, it makes a call to __cxa_end_catch
