#File: katana.org
#Author: James Oakley
#Written For: Dartmouth College
#License: GNU General Public License
#Date, January, 2010
#Description: validate the output of a single unit test for katana

       Katana: A Userland Toolchain-Oriented Hotpatching System

* Introduction
  Katana aims to provide a hot-patching system for userland. Further
  it aims to work with existing toolchains and formats so as to be
  easy to use and to hopefully pave the way for incorporating patching
  as a standard part of the toolchain. Because of this aim, Katana
  operates at the object level rather than requiring any access to the
  source code itself. This has the added bonus of making it, in
  theory, language agnostic (although no work has been done to test it
  with anything besides programs written in C). A diagram of software
  lifecycle with hotpatching is shown below

  [[./software_lifecycle.png]]

  There are other hotpatching systems in existence. The curious are
  invited to explore Ginseng and Polus. Both of these systems parse
  the source code, which adds significant complexity to them and
  results in significant programmer annotation of the code to give
  hints to the systems. Ginseng uses complicated type-wrappers
  when patching variables which does not fit cleanly with existing
  executables and has some impact on the performance of the
  software. Ginseng is considerably more mature than Katana,
  however. Neither system is production ready, but Ginseng is probably
  closer than Katana at the moment.

  The system most like Katana in many ways is KSplice, and the curious
  reader is definitely invited to investigate. KSplice patches the
  kernel and not userland, does not attempt to patch variables, 
* What Katana Does
* What Katan Does Not Do (Yet)
* How to Use Katana
  Katana is intended to be used in two stages. The first stage
  generates a patch object from two different versions of an
  treee. By an object tree, we mean the set of object files (.o files)
  and the executable binary they comprise. Katana works completely at
  the object level, so the source code itself is not strictly
  required, although all objects must be compiled with debugging
  information. This step may be done by the software vendor. In the
  second stage, the patch is applied to a running process. The
  original source trees are not necessary during patch application, as
  the patch object contains all information necessary to patch the
  in-memory process at the object level. It is also possible to view
  the contents of a patch object in a human-readable way for the
  purposes of sanity-checking, determining what changes the patch
  makes, etc.
** Preparing a Package for Patching Support
   Katana aims to be much less invasive than other hot-patching system
   and require minimal work to be used with any project. It does,
   however, have some requirements.\\
   Required CFLAGS:
   + -g

   Recommended CFLAGS:
   + -ffunction-sections
   + -fdata-sections
     
   Recommended LDFLAGS:
   + --emit-relocs

** To Generate a Patch 
** To Apply a Patch
** To View a Patch
** See Also 
   the katana manpage
* Patch Object Format
* Patch Generation Process
* Patch Application Process
* Roadmap
