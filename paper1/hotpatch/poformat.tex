\section{Patch Object Format}
\label{sec:poformat}
%\subsection{Reasons and Needs}
{\bf Reasons and Needs.}
We have developed a Patch Object format for which the following holds:
\begin{itemize}
 \item A PO is a valid ELF file.
 \item A PO utilizes DWARF information to describe types, variables, and functions requiring patching.
 \item A PO allows type transformations to be specified using a language defined by the DWARF standard.
\end{itemize}
Through the use of existing standards and well-structured ELF files
utilizing a simple expression language for data patching, we aim to
create patches that are easily examined (or modified) with existing
tools. This easy compatibility with the existing binary tools and
standards brings us to a very good point: why should patching not be a
part of the ABI and of the standard toolchain? This does not
necessarily have to be the precise format we use for Katana. Any such
format that would become a standard, whether an actual standard or a
de-facto standard, should be well vetted by the community, but we argue
that something like this should be included in the standard object
types, along with relocatable objects, executable objects, shared
libraries, and core dumps. Consider the situation. Relocatable objects
containing new code and data which may be inserted at runtime are
nothing new. This is the entire premise of the dynamic
library. User-written functions which may have to run upon this code
injection (in the case of patching data where the desired actions
cannot be determined automatically) already exist as the
\texttt{.init} and \texttt{.fini} sections. Because of this similarity
between some of the functionality needed by patching and the
functionality offered by dynamic
libraries, some previous systems have performed patching by creating
patches as dynamic libraries that contain not only the code and data
to be patched but also the mechanism to perform the patching \cite{ginseng}
\cite{polus}. We argue that
this is an unnecessary mixing of data and logic and, further, that a patch
that contains merely the information necessary to fix a running
process and not the code to do so is more desirable. The code to apply
the patch should live in one place on any given system, as most other
executable content does. We do not embed Emacs within our text files,
after all. Dynamic libraries and other relocatable, linkable objects
do not contain code and data intended to overwrite data in an existing
executable or process. Consider, however, that redefining certain
symbols is only a slight twist on ordinary linker behaviour. Ordinary
linker behaviour for global symbols is to fail if a symbol is defined
more than once. Ordinary behaviour for weak symbols is to use a global
definition if available or the weak symbol otherwise. When performing
dynamic linking, generally the first appropriate symbol encountered in
the chain of symbol tables is used. It is not a far difference to
define the linkage rule that the symbol definition from the most
recent patch takes precedence. Therefore, applying a patch consists of
the following steps
\begin{enumerate}
\item Injecting appropriate sections of the patch into memory. This
includes putting their contents into memory and performing relocations
on these sections (but not on the rest of the in-memory process) so
that they fit into their environment
\item Copying existing data to the appropriate regions of the newly
mapped-in patch
\item Performing relocation on the entire in-memory process such that the
symbols defined by the patch take precedence.
\end{enumerate}
These steps are all such fundamental operations that they should
become universally supported by the ABI and the toolchain. 

On the other hand, note that the specification of a general patch
format does not completely prescribe the patch application. From a
standard patch format, a patcher is still free to make decisions such
as when to patch safely and whether to patch functions by inserting
trampolines in the old versions of the functions or by relocating all
references to the function (we currently do the former in Katana, but
may later transition to doing the latter).

%\subsection{Our Patch Object Format}
{\bf Our Patch Object Format.}
Our Patch Object (PO) format is an ELF-based format. Figure
\ref{fig:elfheaders} shows the sections contained in a simple
patch. \texttt{.text.new} and \texttt{.rodata.new} are of course the
new code and supporting

%\begin{wrapfigure}{l}{0.4\textwidth}
%{\footnotesize
\begin{figure}[ht]
\begin{center}
\begin{verbatim}
  Section Headers:
    [Nr] Name              Type          
    [ 0]                   NULL          
    [ 1] .strtab           STRTAB        
    [ 2] .symtab           SYMTAB        
    [ 3] .text.new         PROGBITS      
    [ 4] .unsafe_functions LOUSER+1
    [ 5] .rodata.new       PROGBITS      
    [ 6] .rela.text.new    RELA          
    [ 7] .debug_info       PROGBITS      
    [ 8] .debug_abbrev     PROGBITS      
    [ 9] .debug_frame      PROGBITS      
    [10] .rel.debug_info   REL           
    [11] .rel.debug_frame  REL           
\end{verbatim}
\end{center}
%}
\caption{Headers for the PO}
\label{fig:elfheaders}
%\vspace{-10pt}
%\end{wrapfigure}
\end{figure}
constants to inject. \texttt{.rela.text.new} allows \texttt{.text.new}
to be properly relocated after it is adjusted. While System V based
systems use only relocation sections of type \texttt{SHT\_REL}, we
chose to use \texttt{SHT\_RELA} in our patch objects because they make
addends much easier to keep track of as we relocate from patched
binary to patch object to patched process in memory. This is all
really nothing new; storing ELF sections to be injected in-memory has
been done before in other systems \cite{eresi}. What is new in our patch object is
the inclusion of DWARF sections. The \texttt{.debug\_info} section in
an ordinary executable program contains a tree of DIEs (Debugging
Information Entities) with information about every type, variable, and
procedure in each compilation unit in the program. In a patch object,
we store information only about the procedures and variables which
have changed. This of course includes storing the type information for
changed variables. An example of the DWARF DIE information contained
in a patch can be seen in Figure \ref{fig:dies}.

Note that we store considerably less information about each entity
than is typically contained. This is so because we read most of the
information from the DWARF and symbol table information of the
executing process (unless it will have been stripped; then more
information must be stored in the patch). This allows the patch to be
more flexible as it does not require that all variables and procedures
be located at exactly the addresses they were expected to be at when
the patch was generated. This flexibility allows a single patch
between versions \emph{va} and \emph{vb} to patch both an executable
that was originally compiled to \emph{va} and an executable that was
patched from earlier versions to be equivalent to \emph{va}. Ksplice,
one of the few other patchers that operate solely at the binary
level, does not have this capability \cite{ksplice}. We will provide a
mechanism for composing patches such that a patch from version
\emph{va} to \emph{vb} may be composed with a patch from \emph{vb} to
\emph{vc} to produce a patch from \emph{va} to \emph{vb}. Note that
patch versioning is currently a work in progress and not fully
implemented.
%\begin{wrapfigure}{r}{0.5\linewidth}
\begin{figure}[ht]
{\small
\begin{center}
\begin{verbatim}
  .debug_info

  COMPILE_UNIT<header overall offset = 0>:
  <0><   11>	DW_TAG_compile_unit
      DW_AT_name                  main.c

  LOCAL_SYMBOLS:
  <1><   19>	DW_TAG_subprogram
      DW_AT_name                  printThings
      DW_AT_low_pc                0x0
      DW_AT_high_pc               0x70
  <1><   40>	DW_TAG_structure_type
      DW_AT_name                  _Foo
      DW_AT_byte_size             16
      DW_AT_MIPS_fde              16
      DW_AT_sibling               <93>
  <2><   55>	DW_TAG_member
      DW_AT_name                  field1
  <2><   63>	DW_TAG_member
      DW_AT_name                  field_extra
  <2><   76>	DW_TAG_member
      DW_AT_name                  field2
  <2><   84>	DW_TAG_member
      DW_AT_name                  field3
  <1><   93>	DW_TAG_base_type
      DW_AT_name                  int
      DW_AT_byte_size             4
  <1><   99>	DW_TAG_variable
      DW_AT_name                  bar
      DW_AT_type                  <40>
\end{verbatim}
\end{center}
}
\caption{DWARF DIEs in the PO}
\label{fig:dies}
\vspace{-10pt}
\end{figure}
%\end{wrapfigure}

Most of the information in the DIE tree is concerned only with names
or how to locate code within the patch object (high and low pc). Of
special interest, however, is the \texttt{fde} attribute of the
\texttt{DW\_TAG\_structure\_type}. This attribute specifies an offset
in the \texttt{.debug\_frame} section of an FDE (Frame Description
Entity). DWARF FDEs are designed for use in transforming one call
frame into the previous call frame, and thereby walking up a call
stack for either debugging purposes or exception-handling purposes
(using the \texttt{.eh\_frame} section). Transforming one call frame
to another, however, is not such a different operation from
transforming one structure to another version of the same
structure. We have aided this use with an implementation of the DWARF
virtual machine that defines several special register types
(exploiting the fact that for the purposes of generality, DWARF
registers are specified as LEB128 numbers, giving an unlimited number
of registers). The DWARF register instructions contained in the FDE
referenced in Figure \ref{fig:dies} for copying \texttt{field1}, \texttt{field2}, and
\texttt{field3} from the original version of a structure \texttt{\_Foo}
to a new version of \texttt{\_Foo} that has gained the extra member
\texttt{field\_extra} in the middle of the existing fields would be
represented as in Figure \ref{fig:fdeinstrs}.
\begin{figure*}[ht]
{\small
\begin{center}
\begin{verbatim}
DW_CFA_register {CURR_TARG_NEW,0x4 bytes,0x0 off} {CURR_TARG_OLD,0x4 bytes,0x0 off} 
DW_CFA_register {CURR_TARG_NEW,0x4 bytes,0x8 off} {CURR_TARG_OLD,0x4 bytes,0x4 off} 
DW_CFA_register {CURR_TARG_NEW,0x4 bytes,0xc off} {CURR_TARG_OLD,0x4 bytes,0x8 off} 
\end{verbatim}
\end{center}
}
\caption{FDE instructions for data patching}
\label{fig:fdeinstrs}
\end{figure*}

\texttt{CURR\_TARG\_NEW} and \texttt{CURR\_TARG\_OLD} are special
symbolic values defined by the virtual machine. If we are patching the
variable \texttt{bar}, then the \texttt{CURR\_TARG\_OLD} will be the old address of \texttt{bar}
(its value in the symbol table), and \texttt{CURR\_TARG\_NEW} will be the new
address bar is being relocated to. Our registers take advantage of the
LEB128 encoding to hold a considerable amount of information in the
register identifier. In the case seen above, the first byte identifies
the class of the register (\texttt{CURR\_TARG\_NEW} or \texttt{CURR\_TARG\_OLD} in this
example), the following word specifies the size of the storage
addressed (this is included so that register assignments may copy an
arbitrary number of bytes), and the final word specifies an offset
from the address referred to by \texttt{CURR\_TARG\_}(\texttt{NEW}|\texttt{OLD}).

% LocalWords:  toolchain linkable init fini FDE FDEs DIEs Polus CURR TARG LEB
% LocalWords:  CFA DW Foo
