\section{Katana Design}
\label{sec:design}

In our prototype, a patch is may be generated as follows. The source
directory corresponding to the target to be patched is replicated and
the source code is patched to the version desired. The modified source
tree is then built, and compared with the original source tree at the
object (.o) level. Those object files which have changed between the
modified and original source trees are added to the list of objects
which must be examined for type and code transformations. Future work
will include use of the {\it inotify} mechanism to avoid potentially
expensive recursive directory comparison and provide more precise
notification of changed files.

% Katana leverages the typical Unix {\tt Makefile} build mechanism to track
% file-level dependencies.  Normally, after applying a source patch file
% and performing a top-level {\tt make}, only those object files whose
% underlying sources have changed are rebuilt.  Katana thus tracks
% object-level (.o) dependencies as follows.  We first replicate all
% object files and the ELF executable from the existing source tree.  We
% then apply the patch to the {\it original} source tree.  At this
% point, only source files have been modified. Next, using the Linux
% kernel's {\it inotify} mechanism\footnote{{\it inotify} allows the
%   registration of filesystem triggers. We use inotify to avoid potentially
%   expensive recursive directory comparisons.}, Katana sets up a notification
% on the original source tree, so that it knows when an object file is
% created or modified under the original tree.  Finally, we perform the
% top-level {\tt make} under this source and record all created/modified
% object files, along with the newly created executable. The use of
% inotify is not inherent to our general patching mechanism, and indeed
% our present prototype only compares two directory trees and examines
% all object files.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.25]{making.pdf}
\end{center}
\caption{{\small {\it An Example Code Base.} From the top: each source
    file creates a corresponding object file; multiple object files
    are combined into intermediate compilation units (CU); and
    multiple CUs are merged to form the executable. All shaded blocks
    indicate modified files.}}
\label{fig:making}
\end{figure}

%reworded to how we're actually doing it now
% Figure~\ref{fig:making} illustrates how object files are modified by
% {\tt make} as a result of source-level changes.  Katana only considers
% objects that are closest to the source files and ignores all other
% intermediate object files and compilation units (CU).  Hence, in
% Figure~\ref{fig:making}, Katana only records the shaded circle-objects
% along with the final executable.

To dynamically update the running application, Katana needs to patch
both the {\bf code} and the {\bf data} within the process.  It first
creates a {\it patch object} (PO): an ELF file with sections that
indicate the type of patch (code or data), the patch offsets and
lengths within the process address space, patch data, function and
data names, {\it etc.}. The patch object may then be applied to the
target at any time.
%The following sections explain how Katana
%handles both code and data patching.
