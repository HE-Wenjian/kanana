\section{Discussion}

{\bf When to apply the patch.}
%
Dynamically updating a running application requires diligence and
patience. One cannot update the target application without any
knowledge of the program's execution state, by which we mean the
program stack, processor registers {\it etc}.  Even after possessing
this information, the application has to be in what we call a ``safe
state'' for Katana to apply the patch. We characterize a program state
as a {\it safe state} if the following two conditions hold:
\begin{itemize}
\item All activation frames in the program stack belong to functions
  that {\it do not} get updated during code patching. It is easy to
  verify this by comparing each function on the stack to the list of
  upgradeable functions contained within the PO.

\item All activation frames in the program stack belong to functions
  that do not access any global/static symbols identified during {\it
    Data Traversal}, and do not define any local variables of the
  modified types identified during {\it Type Discovery}. Again, since
  we maintain type and variable definitions within the PO, verifying
  this condition is easy.
\end{itemize}

Given the patch object, Katana uses Linux's {\tt ptrace} interface to
temporarily halt the execution of the target process, query the
current execution stack and determine if the application is currently
in a safe state. If so, then Katana applies the code patch followed by
the data patch. We note that it is not possible to apply the code and
data patches at different times since new code likely uses the new
data, and hence postponing data patching to when only the second
condition is satisfied is impractical and unsafe.

Let $A$ denote be the current activation frame on the program stack,
and the notation $(X:Y)$ define all frames from $X$ to $Y$ (on a time
scale, $X$ precedes $Y$) on the stack; so $(1:A)$ defines the current
stack. Now, in case we determine $(1:A)$ to be an unsafe state, we
could repeatedly keep querying the stack until the application reaches
some safe state. However, this is highly inefficient and cumbersome.


Instead, when we determine the program to be in an unsafe state, we
traverse up the stack from $A$, and for each preceding frame (say
$A'$), we determine if $(1:A')$ is a safe state. This takes into
consideration only $A'$ and all other frames preceding it. If $(1:A')$
is a safe state, then we insert a breakpoint on the return instruction
pointer ({\tt EIP}) pointed to by the successive frame: $(A' +
1)$. What this guarantees us is that when this breakpoint is hit, the
state of the program stack will be $(1:A')$. Since we just determined
this to be a safe state, we can reliably conduct the patching
procedure. If however, no such frames preceding $A$ satisfy a safe
state, then it means that the application cannot be patched
successfully in its current execution since there will always be a
function that violates our safety condition.

Finally we note that even after inserting a breakpoint, the problem of
determining {\it when} the breakpoint will be hit is essentially a
hard one, and so in such cases, Katana can provide no time-bounding
guarantees. Still, this is a cleaner and more efficient approach than
just na\"{i}vely retrying the full update procedure, which is both an
expensive and incomplete solution.
%JMHO:
In cases where the timely (or even eventual) application of a patch
seems unlikely, it would be possible to add support for programmers to
manually specify safe places for patching to occur. For programs built
around a central loop (the vast majority of long-running programs),
the likelihood of safe patching can be expedited by isolating the main
loop into a simple routine unlikely to ever need patching.
%JHMO end

%\subsection{Multithreading}

{\bf Address Space Randomization.}
%
{\em Load-time address randomization} has become a stable and popular
way of raising the bar for attackers, and so we must discuss how it 
interacts with our patching scheme. 
%
The gist of randomization schemes is invalidating various default
assumptions regarding the locations of code and data elements that
might facilitate exploitation.
%
%
%SB: condense
% ``Randomization''\footnote{We note that gist of this defense is not
%   randomness as such, but rather increasing the targets' diversity,
%   and denying the convenience of ``code once, run everywhere'' to the
%   attackers.}  is usually the task of the loader and the dynamic
% linker, which, at the time when a process' virtual address space is
% created or new code is loaded into it, modify its layout from the one
% prescribed by the linker that created the original executable's ELF
% structures. In particular, the virtual addresses of loadable segments
% in the file are shifted by a random\footnote{In reality, the choice of
%   offset is still limited by the platform's alignment requirements}
% offset.  This implies that the loader must perform {\em relocation},
% and indeed the code that can be so treated must be accompanied by
% relocation sections.
%
In particular, the virtual addresses of loadable segments
 are displaced by random\footnote{In reality, the choice of
   offset is still limited by the platform's alignment requirements.}
offsets by the loader, which {\em relocates} them (using their
accompanying relocation sections).
% The sections that can be so treated must be accompanied by
% relocation sections.

Patching %``randomly'' 
relocated code with our PO files requires
knowledge of the displacements introduced at loading-and-relocation
time. While there is no common ABI standard for saving this
information, conceptually it is no different from saving virtual
addresses of other files' loaded symbols in the {\it Global Offset Table}
(GOT). We note that the names of the constituent object files themselves 
are customarily included in the symbol tables, and that the symbol
table entry format can be easily adopted for storing virtual addresses
of the %``randomly'' 
relocated objects.

Thus, at the cost of small modifications to the OS loader and the 
dynamic linker, we can make the information on the layout of the
``randomly'' relocated executable and libraries available to
our patching process driven by our POs.\footnote{We note that saving 
this information 
%
about the post-relocation layout of the process 
does not weaken ``randomization'', because 
the latter does not assume the attacker's ability to arbitrarily read 
process memory (in which case the addresses of required symbols are
easily found by scanning it %). %
for their code or data patterns), 
but rather breaks hard-coding of these symbols' expected addresses.
} 

{\bf Future work.} Katana is a work in progress.
%JMHO:
We have demonstrated code patching (including dynamically linked
functions), the use of our patch object format (discussed in detail in
Section \ref{sec:poformat}), and data patching including complex
structures and variable addition. The remainder of the system is still
under development. In the future we
%JMHO end
must address several 
important engineering issues, such as interaction of patched code with
dynamically loaded libraries (including the {\em dlopen} mechanism),
and assuring that accumulation of administered patches does not lead to
unacceptable performance degradation. It also poses a broader question
of describing and detecting software designs not amenable to its runtime
patching and steering programmers to avoid them if possible. 
