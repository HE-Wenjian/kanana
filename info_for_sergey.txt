To generate the patch file, it's run as

$./katana -g -o test1.po tests/test1_basic/v0/test tests/test1_basic/v1/test

The -g flag specifies that we are generating a patch. The -o FILENAME
argument specifies the output. The remaining two arguments are the old
and new versions of the binary respectively (I haven't written the
inotify stuff and whatnot yet).

I've attached the test1.po file generated by that command. Some information on that file


$readelf -S test1.po
  There are 11 section headers, starting at offset 0x4cc:

  Section Headers:
    [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
    [ 0]                   NULL            00000000 000000 000000 00      0   0  0
    [ 1] .strtab           STRTAB          00000000 000034 0000f7 00      0   0  1
    [ 2] .symtab           SYMTAB          00000000 00012c 000100 10      1  10  4
    [ 3] .text.new         PROGBITS        00000000 00022c 000070 00      0   0  1
    [ 4] .rodata.new       PROGBITS        00000000 00029c 00006e 00      0   0  1
    [ 5] .rela.text.new    RELA            00000000 00030c 000090 0c      0   0  4
    [ 6] .debug_info       PROGBITS        00000000 00039c 00006e 00      0   0  1
    [ 7] .debug_abbrev     PROGBITS        00000000 00040a 00003a 00      0   0  1
    [ 8] .debug_frame      PROGBITS        00000000 000444 000050 00   o  0   0  1
    [ 9] .rel.debug_info   REL             00000000 000494 000028 08      2   6  1
    [10] .rel.debug_frame  REL             00000000 0004bc 000010 08      2   8  1

This shows the sections needed in a patch and that the patch is indeed an ELF file

$dwarfdump -i test1.po
  .debug_info

  COMPILE_UNIT<header overall offset = 0>:
  <0><   11>	DW_TAG_compile_unit
      DW_AT_name                  main.c

  LOCAL_SYMBOLS:
  <1><   19>	DW_TAG_subprogram
      DW_AT_name                  printThings
      DW_AT_low_pc                0x0
      DW_AT_high_pc               0x70
  <1><   40>	DW_TAG_structure_type
      DW_AT_name                  _Foo
      DW_AT_byte_size             16
      DW_AT_MIPS_fde              16
      DW_AT_sibling               <93>
  <2><   55>	DW_TAG_member
      DW_AT_name                  field1
  <2><   63>	DW_TAG_member
      DW_AT_name                  field_extra
  <2><   76>	DW_TAG_member
      DW_AT_name                  field2
  <2><   84>	DW_TAG_member
      DW_AT_name                  field3
  <1><   93>	DW_TAG_base_type
      DW_AT_name                  int
      DW_AT_byte_size             4
  <1><   99>	DW_TAG_variable
      DW_AT_name                  bar
      DW_AT_type                  <40>

This shows DWARF information about all functions and variables we must
patch in each compilation unit

Also of interest perhaps are the rules used to transform types. There
is one FDE per type that needs to be transformed (note the
DW_AT_MIPS_fde attribute on the DW_TAG_structure_type die). The
registers are extended with special meanings for our patching Dwarf
VM. I have a small hacked up program that prints the FDE info. I don't
show the full command-line and output because it's very messy and
temporary, but a portion of the output is:

  --------FDE-----
  Instructions:
    DW_CFA_register {CURR_TARG_NEW,0x4 bytes,0x0 off} {CURR_TARG_OLD,0x4 bytes,0x0 off} 
    DW_CFA_register {CURR_TARG_NEW,0x4 bytes,0x8 off} {CURR_TARG_OLD,0x4 bytes,0x4 off} 
    DW_CFA_register {CURR_TARG_NEW,0x4 bytes,0xc off} {CURR_TARG_OLD,0x4 bytes,0x8 off} 
    DW_CFA_nop
    DW_CFA_nop
    DW_CFA_nop
  The table would be as follows
    {CURR_TARG_NEW,0x4 bytes,0x0 off} = {CURR_TARG_OLD,0x4 bytes,0x0 off}
    {CURR_TARG_NEW,0x4 bytes,0x8 off} = {CURR_TARG_OLD,0x4 bytes,0x4 off}
    {CURR_TARG_NEW,0x4 bytes,0xc off} = {CURR_TARG_OLD,0x4 bytes,0x8 off}

This clearly involves special registers. CURR_TARG_NEW and
CURR_TARG_OLD are special symbols defined by the virtual machine. If
we are patching the variable 'bar', then the CURR_TARG_OLD will be the
old address of bar (it's value in the symbol table) and CURR_TARG_NEW
will be the new address bar is being relocated to. Our registers take
advantage of the LEB128 encoding to hold a considerable amount of
information in the register identifier. In the case seen above, the
first byte identifies the class of the reigister (CURR_TARG_NEW or
CURR_TARG_OLD in this example), the following word specifies the size
of the storage addressed (this is included so that register
assignments may copy an arbitrary number of bytes), and the final word
specifies an offset from the address referred to by
CURR_TARG_(NEW|OLD).


The patching itself is then done with the following commands
$ tests/test1_basic/v0/test
(then, from another shell while test is still running)
$ ./katana -p test1.po `pgrep test`

The output from test looks something like this
  Foo: 42,66
  field 1 at addr: 804a020, field 2 at addr: 804a024
  Foo: 42,66
  field 1 at addr: 804a020, field 2 at addr: 804a024
  Foo: 42,66
  field 1 at addr: 804a020, field 2 at addr: 804a024
  this is print things version 1
  Foo: 42,66
  field 1 at addr: 4002116e, field 2 at addr: 40021176
  this is print things version 1
  Foo: 42,66
  field 1 at addr: 4002116e, field 2 at addr: 40021176
  this is print things version 1

Notice the change in address once patching occurs. The data, however,
remains the same because the fields within the structure are copied to
the new location correctly. Also, the binary located from
/proc/PID/exe is also patched on disk with symbol and relocation
information corresponding to the transformations applied
in-memory. Keeping this up to date makes patching of binaries which
have already been patched possible (this feature is not yet fully
implemented, so this is in theory, not in demonstrable practice).
